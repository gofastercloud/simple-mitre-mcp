/**
 * UI Components for MITRE ATT&CK Intelligence Platform
 * 
 * This module contains all the UI component classes for the web interface,
 * including the SystemDashboard, SmartFormControls, ToolsSection, and ResultsSection.
 */

/**
 * System Dashboard Component
 * 
 * Displays comprehensive system information including entity counts,
 * server information, and data statistics with professional styling
 * and responsive design.
 */
class SystemDashboard {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.systemInfo = null;
        this.isLoading = false;
        this.hasError = false;
        this.errorMessage = '';
        
        if (!this.container) {
            throw new Error(`Container element with ID '${containerId}' not found`);
        }
    }

    /**
     * Render the dashboard with loading state
     */
    async render() {
        try {
            this.isLoading = true;
            this.hasError = false;
            this.renderLoadingState();
            
            // Fetch system information
            this.systemInfo = await api.getSystemInfo();
            
            this.isLoading = false;
            this.renderDashboard();
            this.updateStats();
            
        } catch (error) {
            console.error('Failed to render dashboard:', error);
            this.isLoading = false;
            this.hasError = true;
            this.errorMessage = error.message || 'Failed to load system information';
            this.renderError();
        }
    }

    /**
     * Render loading state with skeleton cards
     */
    renderLoadingState() {
        this.container.innerHTML = this.getLoadingTemplate();
    }

    /**
     * Render error state with retry option
     */
    renderError() {
        this.container.innerHTML = this.getErrorTemplate();
        this.setupErrorEventListeners();
    }

    /**
     * Render the complete dashboard
     */
    renderDashboard() {
        this.container.innerHTML = this.getDashboardTemplate();
        this.setupEventListeners();
    }

    /**
     * Get the loading template with skeleton cards
     */
    getLoadingTemplate() {
        return `
            <div class="system-dashboard">
                <div class="dashboard-header">
                    <h1 class="dashboard-title">
                        <i class="bi bi-shield-check me-2"></i>
                        MITRE ATT&CK Intelligence Platform
                    </h1>
                    <p class="dashboard-subtitle">Advanced Threat Intelligence Analysis & Exploration</p>
                </div>
                
                <div class="stats-grid">
                    ${this.getSkeletonStatCard('Techniques')}
                    ${this.getSkeletonStatCard('Tactics')}
                    ${this.getSkeletonStatCard('Threat Groups')}
                    ${this.getSkeletonStatCard('Mitigations')}
                    ${this.getSkeletonStatCard('Relationships')}
                    ${this.getSkeletonStatCard('Analysis Tools')}
                </div>
                
                <div class="server-info">
                    <div class="info-item">
                        <span class="info-label">Server Version</span>
                        <div class="loading-skeleton" style="height: 1.5rem; width: 80px;"></div>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Data Source</span>
                        <div class="loading-skeleton" style="height: 1.5rem; width: 120px;"></div>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Last Updated</span>
                        <div class="loading-skeleton" style="height: 1.5rem; width: 100px;"></div>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Get skeleton stat card for loading state
     */
    getSkeletonStatCard(label) {
        return `
            <div class="stat-card loading">
                <div class="loading-skeleton" style="height: 2.5rem; width: 60px; margin: 0 auto 0.5rem;"></div>
                <div class="stat-label">${label}</div>
            </div>
        `;
    }

    /**
     * Get error template with retry button
     */
    getErrorTemplate() {
        return `
            <div class="system-dashboard">
                <div class="dashboard-header">
                    <h1 class="dashboard-title">
                        <i class="bi bi-shield-check me-2"></i>
                        MITRE ATT&CK Intelligence Platform
                    </h1>
                    <p class="dashboard-subtitle">Advanced Threat Intelligence Analysis & Exploration</p>
                </div>
                
                <div class="alert alert-danger" role="alert">
                    <div class="d-flex align-items-center mb-2">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        <strong>Failed to Load System Information</strong>
                    </div>
                    <p class="mb-3">${this.errorMessage}</p>
                    <button type="button" class="btn btn-outline-danger" id="retry-dashboard">
                        <i class="bi bi-arrow-clockwise me-1"></i>
                        Retry
                    </button>
                </div>
            </div>
        `;
    }

    /**
     * Get the main dashboard template
     */
    getDashboardTemplate() {
        return `
            <div class="system-dashboard">
                <div class="dashboard-header">
                    <h1 class="dashboard-title">
                        <i class="bi bi-shield-check me-2"></i>
                        MITRE ATT&CK Intelligence Platform
                    </h1>
                    <p class="dashboard-subtitle">Advanced Threat Intelligence Analysis & Exploration</p>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card" data-stat="techniques">
                        <div class="stat-number" id="techniques-count">-</div>
                        <div class="stat-label">Techniques</div>
                    </div>
                    <div class="stat-card" data-stat="tactics">
                        <div class="stat-number" id="tactics-count">-</div>
                        <div class="stat-label">Tactics</div>
                    </div>
                    <div class="stat-card" data-stat="groups">
                        <div class="stat-number" id="groups-count">-</div>
                        <div class="stat-label">Threat Groups</div>
                    </div>
                    <div class="stat-card" data-stat="mitigations">
                        <div class="stat-number" id="mitigations-count">-</div>
                        <div class="stat-label">Mitigations</div>
                    </div>
                    <div class="stat-card" data-stat="relationships">
                        <div class="stat-number" id="relationships-count">-</div>
                        <div class="stat-label">Relationships</div>
                    </div>
                    <div class="stat-card" data-stat="tools">
                        <div class="stat-number">8</div>
                        <div class="stat-label">Analysis Tools</div>
                    </div>
                </div>
                
                <div class="server-info">
                    <div class="info-item">
                        <span class="info-label">Server Version</span>
                        <span class="info-value" id="server-version">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Data Source</span>
                        <span class="info-value" id="data-source">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Last Updated</span>
                        <span class="info-value" id="last-updated">-</span>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Update statistics with data from system info
     */
    updateStats() {
        if (!this.systemInfo) return;

        try {
            const stats = this.systemInfo.data_statistics || {};
            
            // Update entity counts with animation
            this.animateStatUpdate('techniques-count', stats.techniques_count || 0);
            this.animateStatUpdate('tactics-count', stats.tactics_count || 0);
            this.animateStatUpdate('groups-count', stats.groups_count || 0);
            this.animateStatUpdate('mitigations-count', stats.mitigations_count || 0);
            this.animateStatUpdate('relationships-count', stats.relationships_count || 0);

            // Update server information
            const serverInfo = this.systemInfo.server_info || {};
            document.getElementById('server-version').textContent = serverInfo.version || 'Unknown';
            document.getElementById('data-source').textContent = serverInfo.data_source || 'Unknown';
            
            // Format and display last updated time
            const lastUpdated = serverInfo.startup_time ? 
                new Date(serverInfo.startup_time).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                }) : 'Unknown';
            document.getElementById('last-updated').textContent = lastUpdated;

        } catch (error) {
            console.error('Error updating stats:', error);
        }
    }

    /**
     * Animate stat number updates with counting effect
     */
    animateStatUpdate(elementId, targetValue) {
        const element = document.getElementById(elementId);
        if (!element) return;

        const startValue = 0;
        const duration = 1000; // 1 second
        const startTime = performance.now();

        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Use easing function for smooth animation
            const easeOutQuart = 1 - Math.pow(1 - progress, 4);
            const currentValue = Math.floor(startValue + (targetValue - startValue) * easeOutQuart);
            
            element.textContent = currentValue.toLocaleString();
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                element.textContent = targetValue.toLocaleString();
            }
        };

        requestAnimationFrame(animate);
    }

    /**
     * Setup event listeners for dashboard interactions
     */
    setupEventListeners() {
        // Add hover effects for stat cards
        const statCards = this.container.querySelectorAll('.stat-card');
        statCards.forEach(card => {
            card.addEventListener('mouseenter', this.handleStatCardHover.bind(this));
            card.addEventListener('mouseleave', this.handleStatCardLeave.bind(this));
        });

        // Add click handlers for stat cards (future enhancement)
        statCards.forEach(card => {
            card.addEventListener('click', this.handleStatCardClick.bind(this));
        });
    }

    /**
     * Setup event listeners for error state
     */
    setupErrorEventListeners() {
        const retryButton = document.getElementById('retry-dashboard');
        if (retryButton) {
            retryButton.addEventListener('click', () => {
                this.render();
            });
        }
    }

    /**
     * Handle stat card hover effect
     */
    handleStatCardHover(event) {
        const card = event.currentTarget;
        const statType = card.dataset.stat;
        
        // Add visual feedback
        card.style.transform = 'scale(1.05)';
        card.style.boxShadow = 'var(--shadow-lg)';
        
        // Show tooltip with additional information (future enhancement)
        this.showStatTooltip(card, statType);
    }

    /**
     * Handle stat card leave effect
     */
    handleStatCardLeave(event) {
        const card = event.currentTarget;
        
        // Reset visual state
        card.style.transform = '';
        card.style.boxShadow = '';
        
        // Hide tooltip
        this.hideStatTooltip();
    }

    /**
     * Handle stat card click
     */
    handleStatCardClick(event) {
        const card = event.currentTarget;
        const statType = card.dataset.stat;
        
        // Add click animation
        card.style.transform = 'scale(0.95)';
        setTimeout(() => {
            card.style.transform = '';
        }, 150);
        
        // Emit custom event for other components to listen to
        this.container.dispatchEvent(new CustomEvent('statCardClick', {
            detail: { statType, systemInfo: this.systemInfo }
        }));
    }

    /**
     * Show tooltip for stat card (placeholder for future enhancement)
     */
    showStatTooltip(card, statType) {
        // Future enhancement: show detailed information about the stat
        // For now, just add a title attribute
        const tooltips = {
            techniques: 'Attack techniques available in the dataset',
            tactics: 'Tactical objectives in the MITRE ATT&CK framework',
            groups: 'Known threat actor groups and campaigns',
            mitigations: 'Security controls and countermeasures',
            relationships: 'Connections between entities in the dataset',
            tools: 'Available analysis and exploration tools'
        };
        
        card.title = tooltips[statType] || '';
    }

    /**
     * Hide tooltip
     */
    hideStatTooltip() {
        // Remove any active tooltips
        const cards = this.container.querySelectorAll('.stat-card');
        cards.forEach(card => {
            card.removeAttribute('title');
        });
    }

    /**
     * Refresh dashboard data
     */
    async refresh() {
        await this.render();
    }

    /**
     * Get current system information
     */
    getSystemInfo() {
        return this.systemInfo;
    }

    /**
     * Check if dashboard is currently loading
     */
    isLoadingData() {
        return this.isLoading;
    }

    /**
     * Check if dashboard has an error
     */
    hasErrorState() {
        return this.hasError;
    }

    /**
     * Get current error message
     */
    getErrorMessage() {
        return this.errorMessage;
    }

    /**
     * Destroy the dashboard and clean up event listeners
     */
    destroy() {
        if (this.container) {
            this.container.innerHTML = '';
        }
    }
}

/**
 * Smart Form Controls Component
 * 
 * Provides intelligent form population with dropdowns for threat groups,
 * tactics, and autocomplete for techniques. Includes form validation,
 * user feedback, and Bootstrap styling with responsive design.
 */
class SmartFormControls {
    constructor() {
        this.groupsData = [];
        this.tacticsData = [];
        this.techniquesCache = new Map();
        this.initialized = false;
        this.isLoading = false;
        this.hasError = false;
        this.errorMessage = '';
        
        // Configuration
        this.autocompleteMinLength = 2;
        this.autocompleteDelay = 300;
        this.maxSuggestions = 10;
        
        // Debounce timers
        this.debounceTimers = new Map();
        
        // Event listeners storage for cleanup
        this.eventListeners = new Map();
    }

    /**
     * Initialize smart form controls by loading data and setting up controls
     */
    async initialize() {
        if (this.initialized || this.isLoading) return;
        
        try {
            this.isLoading = true;
            this.hasError = false;
            
            console.log('Initializing smart form controls...');
            
            // Load data in parallel for better performance
            await Promise.all([
                this.loadGroups(),
                this.loadTactics()
            ]);
            
            // Setup form controls after data is loaded
            this.setupFormControls();
            
            this.initialized = true;
            this.isLoading = false;
            
            console.log('Smart form controls initialized successfully');
            
        } catch (error) {
            console.error('Failed to initialize smart form controls:', error);
            this.isLoading = false;
            this.hasError = true;
            this.errorMessage = error.message || 'Failed to initialize form controls';
            
            // Show error feedback to user
            this.showErrorFeedback('Failed to load form data. Some features may not work properly.');
        }
    }

    /**
     * Load threat groups data from API
     */
    async loadGroups() {
        try {
            console.log('Loading threat groups data...');
            const response = await api.getGroups();
            this.groupsData = Array.isArray(response) ? response : [];
            console.log(`Loaded ${this.groupsData.length} threat groups`);
        } catch (error) {
            console.error('Failed to load groups:', error);
            this.groupsData = [];
            throw new Error(`Failed to load threat groups: ${error.message}`);
        }
    }

    /**
     * Load tactics data from API
     */
    async loadTactics() {
        try {
            console.log('Loading tactics data...');
            const response = await api.getTactics();
            this.tacticsData = Array.isArray(response) ? response : [];
            console.log(`Loaded ${this.tacticsData.length} tactics`);
        } catch (error) {
            console.error('Failed to load tactics:', error);
            this.tacticsData = [];
            throw new Error(`Failed to load tactics: ${error.message}`);
        }
    }

    /**
     * Setup all form controls on the page
     */
    setupFormControls() {
        // Setup group dropdowns
        this.setupGroupDropdowns();
        
        // Setup tactic dropdowns
        this.setupTacticDropdowns();
        
        // Setup technique autocomplete
        this.setupTechniqueAutocomplete();
        
        // Setup form validation
        this.setupFormValidation();
        
        console.log('Form controls setup completed');
    }

    /**
     * Setup threat group dropdown controls
     */
    setupGroupDropdowns() {
        const groupSelects = document.querySelectorAll('.group-select, [data-smart-control="group"]');
        console.log(`Setting up ${groupSelects.length} group dropdowns`);
        
        groupSelects.forEach(select => {
            this.populateGroupSelect(select);
            this.addSearchFunctionality(select, this.groupsData);
        });
    }

    /**
     * Setup tactic dropdown controls
     */
    setupTacticDropdowns() {
        const tacticSelects = document.querySelectorAll('.tactic-select, [data-smart-control="tactic"]');
        console.log(`Setting up ${tacticSelects.length} tactic dropdowns`);
        
        tacticSelects.forEach(select => {
            this.populateTacticSelect(select);
        });
    }

    /**
     * Setup technique autocomplete controls
     */
    setupTechniqueAutocomplete() {
        const techniqueInputs = document.querySelectorAll('.technique-autocomplete, [data-smart-control="technique"]');
        console.log(`Setting up ${techniqueInputs.length} technique autocomplete inputs`);
        
        techniqueInputs.forEach(input => {
            this.setupAutocomplete(input);
        });
    }

    /**
     * Populate a group select element with data
     */
    populateGroupSelect(selectElement) {
        if (!selectElement) return;
        
        // Clear existing options except placeholder
        const placeholder = selectElement.querySelector('option[value=""]');
        selectElement.innerHTML = '';
        
        // Add placeholder
        const placeholderOption = document.createElement('option');
        placeholderOption.value = '';
        placeholderOption.textContent = placeholder?.textContent || 'Select a threat group...';
        placeholderOption.disabled = true;
        placeholderOption.selected = true;
        selectElement.appendChild(placeholderOption);
        
        // Add group options
        this.groupsData.forEach(group => {
            const option = document.createElement('option');
            option.value = group.id || group.name;
            
            // Create display name with aliases if available
            let displayName = group.name || group.id;
            if (group.aliases && group.aliases.length > 0) {
                displayName += ` (${group.aliases.slice(0, 2).join(', ')})`;
            }
            if (group.id && group.id !== group.name) {
                displayName += ` [${group.id}]`;
            }
            
            option.textContent = displayName;
            option.title = group.description || displayName;
            selectElement.appendChild(option);
        });
        
        // Add Bootstrap styling
        selectElement.classList.add('form-select');
        
        // Wrap in smart control container if not already wrapped
        if (!selectElement.parentElement.classList.contains('smart-form-control')) {
            this.wrapInSmartContainer(selectElement, 'bi-people-fill');
        }
    }

    /**
     * Populate a tactic select element with data
     */
    populateTacticSelect(selectElement) {
        if (!selectElement) return;
        
        // Clear existing options except placeholder
        const placeholder = selectElement.querySelector('option[value=""]');
        selectElement.innerHTML = '';
        
        // Add placeholder
        const placeholderOption = document.createElement('option');
        placeholderOption.value = '';
        placeholderOption.textContent = placeholder?.textContent || 'Select a tactic...';
        placeholderOption.disabled = true;
        placeholderOption.selected = true;
        selectElement.appendChild(placeholderOption);
        
        // Add tactic options
        this.tacticsData.forEach(tactic => {
            const option = document.createElement('option');
            option.value = tactic.id || tactic.name;
            
            // Create display name with proper formatting
            let displayName = tactic.name || tactic.id;
            if (tactic.id && tactic.id !== tactic.name) {
                displayName += ` (${tactic.id})`;
            }
            
            option.textContent = displayName;
            option.title = tactic.description || displayName;
            selectElement.appendChild(option);
        });
        
        // Add Bootstrap styling
        selectElement.classList.add('form-select');
        
        // Wrap in smart control container if not already wrapped
        if (!selectElement.parentElement.classList.contains('smart-form-control')) {
            this.wrapInSmartContainer(selectElement, 'bi-flag-fill');
        }
    }

    /**
     * Setup autocomplete functionality for technique inputs
     */
    setupAutocomplete(inputElement) {
        if (!inputElement) return;
        
        // Add Bootstrap styling
        inputElement.classList.add('form-control');
        
        // Create autocomplete container
        const container = this.createAutocompleteContainer(inputElement);
        
        // Setup event listeners
        this.setupAutocompleteEvents(inputElement, container);
        
        // Wrap in smart control container if not already wrapped
        if (!inputElement.parentElement.classList.contains('smart-form-control')) {
            this.wrapInSmartContainer(inputElement, 'bi-search');
        }
    }

    /**
     * Create autocomplete container and suggestions list
     */
    createAutocompleteContainer(inputElement) {
        // Check if container already exists
        let container = inputElement.parentElement.querySelector('.autocomplete-container');
        if (container) return container;
        
        // Create container
        container = document.createElement('div');
        container.className = 'autocomplete-container';
        
        // Create suggestions list
        const suggestions = document.createElement('div');
        suggestions.className = 'autocomplete-suggestions';
        suggestions.setAttribute('role', 'listbox');
        container.appendChild(suggestions);
        
        // Insert container after input
        inputElement.parentNode.insertBefore(container, inputElement.nextSibling);
        
        return container;
    }

    /**
     * Setup autocomplete event listeners
     */
    setupAutocompleteEvents(inputElement, container) {
        const suggestions = container.querySelector('.autocomplete-suggestions');
        let activeIndex = -1;
        
        // Input event for search
        const inputHandler = (event) => {
            const query = event.target.value.trim();
            
            if (query.length < this.autocompleteMinLength) {
                this.hideSuggestions(suggestions);
                return;
            }
            
            // Debounce the search
            this.debounceSearch(inputElement, query, suggestions);
        };
        
        // Keydown event for navigation
        const keydownHandler = (event) => {
            const suggestionItems = suggestions.querySelectorAll('.autocomplete-suggestion');
            
            switch (event.key) {
                case 'ArrowDown':
                    event.preventDefault();
                    activeIndex = Math.min(activeIndex + 1, suggestionItems.length - 1);
                    this.updateActiveSelection(suggestionItems, activeIndex);
                    break;
                    
                case 'ArrowUp':
                    event.preventDefault();
                    activeIndex = Math.max(activeIndex - 1, -1);
                    this.updateActiveSelection(suggestionItems, activeIndex);
                    break;
                    
                case 'Enter':
                    event.preventDefault();
                    if (activeIndex >= 0 && suggestionItems[activeIndex]) {
                        this.selectSuggestion(inputElement, suggestionItems[activeIndex], suggestions);
                    }
                    break;
                    
                case 'Escape':
                    this.hideSuggestions(suggestions);
                    activeIndex = -1;
                    break;
            }
        };
        
        // Focus event to show suggestions if input has value
        const focusHandler = (event) => {
            const query = event.target.value.trim();
            if (query.length >= this.autocompleteMinLength) {
                this.debounceSearch(inputElement, query, suggestions);
            }
        };
        
        // Blur event to hide suggestions (with delay for click handling)
        const blurHandler = () => {
            setTimeout(() => {
                this.hideSuggestions(suggestions);
                activeIndex = -1;
            }, 150);
        };
        
        // Add event listeners
        inputElement.addEventListener('input', inputHandler);
        inputElement.addEventListener('keydown', keydownHandler);
        inputElement.addEventListener('focus', focusHandler);
        inputElement.addEventListener('blur', blurHandler);
        
        // Store listeners for cleanup
        const listenerId = this.generateListenerId(inputElement);
        this.eventListeners.set(listenerId, {
            element: inputElement,
            listeners: [
                { event: 'input', handler: inputHandler },
                { event: 'keydown', handler: keydownHandler },
                { event: 'focus', handler: focusHandler },
                { event: 'blur', handler: blurHandler }
            ]
        });
    }

    /**
     * Debounce search requests to avoid excessive API calls
     */
    debounceSearch(inputElement, query, suggestions) {
        const timerId = this.generateListenerId(inputElement);
        
        // Clear existing timer
        if (this.debounceTimers.has(timerId)) {
            clearTimeout(this.debounceTimers.get(timerId));
        }
        
        // Set new timer
        const timer = setTimeout(async () => {
            try {
                await this.searchTechniques(query, suggestions, inputElement);
            } catch (error) {
                console.error('Autocomplete search failed:', error);
                this.showSearchError(suggestions);
            }
        }, this.autocompleteDelay);
        
        this.debounceTimers.set(timerId, timer);
    }

    /**
     * Search for techniques and display suggestions
     */
    async searchTechniques(query, suggestions, inputElement) {
        try {
            // Check cache first
            const cacheKey = query.toLowerCase();
            if (this.techniquesCache.has(cacheKey)) {
                const cachedResults = this.techniquesCache.get(cacheKey);
                this.displaySuggestions(cachedResults, suggestions, inputElement);
                return;
            }
            
            // Show loading state
            this.showLoadingState(suggestions);
            
            // Fetch from API
            const techniques = await api.getTechniques(query);
            
            // Cache results
            this.techniquesCache.set(cacheKey, techniques);
            
            // Display suggestions
            this.displaySuggestions(techniques, suggestions, inputElement);
            
        } catch (error) {
            console.error('Failed to search techniques:', error);
            this.showSearchError(suggestions);
        }
    }

    /**
     * Display technique suggestions
     */
    displaySuggestions(techniques, suggestions, inputElement) {
        // Clear existing suggestions
        suggestions.innerHTML = '';
        
        if (!techniques || techniques.length === 0) {
            this.showNoResults(suggestions);
            return;
        }
        
        // Limit results
        const limitedTechniques = techniques.slice(0, this.maxSuggestions);
        
        // Create suggestion items
        limitedTechniques.forEach((technique, index) => {
            const item = this.createSuggestionItem(technique, index);
            item.addEventListener('click', () => {
                this.selectSuggestion(inputElement, item, suggestions);
            });
            suggestions.appendChild(item);
        });
        
        // Show suggestions
        this.showSuggestions(suggestions);
    }

    /**
     * Create a suggestion item element
     */
    createSuggestionItem(technique, index) {
        const item = document.createElement('div');
        item.className = 'autocomplete-suggestion';
        item.setAttribute('role', 'option');
        item.setAttribute('data-index', index);
        item.setAttribute('data-value', technique.id || technique.name);
        
        // Create content with technique ID and name
        const content = document.createElement('div');
        const title = document.createElement('strong');
        title.textContent = technique.name || technique.id;
        content.appendChild(title);
        
        if (technique.id && technique.id !== technique.name) {
            const id = document.createElement('small');
            id.className = 'text-muted ms-2';
            id.textContent = `(${technique.id})`;
            content.appendChild(id);
        }
        
        if (technique.description) {
            const desc = document.createElement('div');
            desc.className = 'small text-muted';
            desc.textContent = technique.description.substring(0, 100) + (technique.description.length > 100 ? '...' : '');
            content.appendChild(desc);
        }
        
        item.appendChild(content);
        return item;
    }

    /**
     * Select a suggestion and update input
     */
    selectSuggestion(inputElement, suggestionItem, suggestions) {
        const value = suggestionItem.getAttribute('data-value');
        const text = suggestionItem.querySelector('strong').textContent;
        
        // Update input value
        inputElement.value = value;
        
        // Trigger change event
        inputElement.dispatchEvent(new Event('change', { bubbles: true }));
        
        // Hide suggestions
        this.hideSuggestions(suggestions);
        
        // Show success feedback
        this.showSelectionFeedback(inputElement, text);
    }

    /**
     * Update active selection in suggestions
     */
    updateActiveSelection(suggestionItems, activeIndex) {
        suggestionItems.forEach((item, index) => {
            if (index === activeIndex) {
                item.classList.add('active');
                item.scrollIntoView({ block: 'nearest' });
            } else {
                item.classList.remove('active');
            }
        });
    }

    /**
     * Show suggestions list
     */
    showSuggestions(suggestions) {
        suggestions.classList.add('show');
    }

    /**
     * Hide suggestions list
     */
    hideSuggestions(suggestions) {
        suggestions.classList.remove('show');
    }

    /**
     * Show loading state in suggestions
     */
    showLoadingState(suggestions) {
        suggestions.innerHTML = `
            <div class="autocomplete-suggestion">
                <div class="loading-spinner">
                    <div class="spinner-border spinner-border-sm" role="status"></div>
                    <span>Searching techniques...</span>
                </div>
            </div>
        `;
        this.showSuggestions(suggestions);
    }

    /**
     * Show no results message
     */
    showNoResults(suggestions) {
        suggestions.innerHTML = `
            <div class="autocomplete-suggestion">
                <div class="text-muted text-center">
                    <i class="bi bi-search me-2"></i>
                    No techniques found
                </div>
            </div>
        `;
        this.showSuggestions(suggestions);
    }

    /**
     * Show search error message
     */
    showSearchError(suggestions) {
        suggestions.innerHTML = `
            <div class="autocomplete-suggestion">
                <div class="text-danger text-center">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    Search failed. Please try again.
                </div>
            </div>
        `;
        this.showSuggestions(suggestions);
    }

    /**
     * Add search functionality to select elements
     */
    addSearchFunctionality(selectElement, data) {
        // This could be enhanced with a searchable dropdown library
        // For now, we'll add a title attribute for better UX
        selectElement.title = `Search among ${data.length} options`;
    }

    /**
     * Wrap form control in smart container with icon
     */
    wrapInSmartContainer(element, iconClass) {
        const parent = element.parentElement;
        
        // Create smart container
        const container = document.createElement('div');
        container.className = 'smart-form-control';
        
        // Move element into container
        parent.insertBefore(container, element);
        container.appendChild(element);
        
        // Add icon
        const icon = document.createElement('i');
        icon.className = `bi ${iconClass} form-icon`;
        container.appendChild(icon);
    }

    /**
     * Setup form validation for all forms
     */
    setupFormValidation() {
        const forms = document.querySelectorAll('form');
        
        forms.forEach(form => {
            form.addEventListener('submit', (event) => {
                if (!this.validateForm(form)) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                form.classList.add('was-validated');
            });
            
            // Real-time validation
            const inputs = form.querySelectorAll('input, select, textarea');
            inputs.forEach(input => {
                input.addEventListener('blur', () => {
                    this.validateField(input);
                });
                
                input.addEventListener('input', () => {
                    if (input.classList.contains('is-invalid')) {
                        this.validateField(input);
                    }
                });
            });
        });
    }

    /**
     * Validate a form
     */
    validateForm(form) {
        let isValid = true;
        const inputs = form.querySelectorAll('input, select, textarea');
        
        inputs.forEach(input => {
            if (!this.validateField(input)) {
                isValid = false;
            }
        });
        
        return isValid;
    }

    /**
     * Validate a single field
     */
    validateField(field) {
        const isRequired = field.hasAttribute('required') || field.classList.contains('required');
        const value = field.value.trim();
        let isValid = true;
        let errorMessage = '';
        
        // Required field validation
        if (isRequired && !value) {
            isValid = false;
            errorMessage = 'This field is required';
        }
        
        // Type-specific validation
        if (value && field.type) {
            switch (field.type) {
                case 'email':
                    if (!this.isValidEmail(value)) {
                        isValid = false;
                        errorMessage = 'Please enter a valid email address';
                    }
                    break;
                    
                case 'url':
                    if (!this.isValidUrl(value)) {
                        isValid = false;
                        errorMessage = 'Please enter a valid URL';
                    }
                    break;
            }
        }
        
        // Update field state
        this.updateFieldValidation(field, isValid, errorMessage);
        
        return isValid;
    }

    /**
     * Update field validation state
     */
    updateFieldValidation(field, isValid, errorMessage) {
        // Remove existing validation classes
        field.classList.remove('is-valid', 'is-invalid');
        
        // Add appropriate class
        if (isValid) {
            field.classList.add('is-valid');
        } else {
            field.classList.add('is-invalid');
        }
        
        // Update or create feedback element
        this.updateValidationFeedback(field, errorMessage, isValid);
    }

    /**
     * Update validation feedback message
     */
    updateValidationFeedback(field, message, isValid) {
        const feedbackClass = isValid ? 'valid-feedback' : 'invalid-feedback';
        let feedback = field.parentElement.querySelector(`.${feedbackClass}`);
        
        if (!feedback) {
            feedback = document.createElement('div');
            feedback.className = feedbackClass;
            field.parentElement.appendChild(feedback);
        }
        
        feedback.textContent = message;
    }

    /**
     * Show error feedback to user
     */
    showErrorFeedback(message) {
        // Create toast notification
        this.showToast('Error', message, 'danger');
    }

    /**
     * Show selection feedback
     */
    showSelectionFeedback(inputElement, selectedText) {
        // Brief visual feedback
        inputElement.classList.add('is-valid');
        setTimeout(() => {
            inputElement.classList.remove('is-valid');
        }, 2000);
    }

    /**
     * Show toast notification
     */
    showToast(title, message, type = 'info') {
        // Create toast container if it doesn't exist
        let container = document.querySelector('.toast-container');
        if (!container) {
            container = document.createElement('div');
            container.className = 'toast-container';
            document.body.appendChild(container);
        }
        
        // Create toast
        const toast = document.createElement('div');
        toast.className = `toast align-items-center text-white bg-${type} border-0`;
        toast.setAttribute('role', 'alert');
        toast.innerHTML = `
            <div class="d-flex">
                <div class="toast-body">
                    <strong>${title}:</strong> ${message}
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
            </div>
        `;
        
        container.appendChild(toast);
        
        // Show toast
        const bsToast = new bootstrap.Toast(toast, { delay: 5000 });
        bsToast.show();
        
        // Remove from DOM after hiding
        toast.addEventListener('hidden.bs.toast', () => {
            toast.remove();
        });
    }

    /**
     * Utility methods
     */
    isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    isValidUrl(url) {
        try {
            new URL(url);
            return true;
        } catch {
            return false;
        }
    }

    generateListenerId(element) {
        return element.id || element.name || `element_${Date.now()}_${Math.random()}`;
    }

    /**
     * Refresh form controls data
     */
    async refresh() {
        this.initialized = false;
        this.techniquesCache.clear();
        await this.initialize();
    }

    /**
     * Get current data statistics
     */
    getDataStats() {
        return {
            groups: this.groupsData.length,
            tactics: this.tacticsData.length,
            techniquesCached: this.techniquesCache.size,
            initialized: this.initialized,
            hasError: this.hasError
        };
    }

    /**
     * Check if smart form controls are ready
     */
    isReady() {
        return this.initialized && !this.isLoading && !this.hasError;
    }

    /**
     * Clean up event listeners and resources
     */
    destroy() {
        // Clear debounce timers
        this.debounceTimers.forEach(timer => clearTimeout(timer));
        this.debounceTimers.clear();
        
        // Remove event listeners
        this.eventListeners.forEach(({ element, listeners }) => {
            listeners.forEach(({ event, handler }) => {
                element.removeEventListener(event, handler);
            });
        });
        this.eventListeners.clear();
        
        // Clear cache
        this.techniquesCache.clear();
        
        // Reset state
        this.initialized = false;
        this.isLoading = false;
        this.hasError = false;
        
        console.log('Smart form controls destroyed');
    }
}

/**
 * Tools Section Component
 * 
 * Dynamically generates forms for all 8 MCP tools with separation between
 * basic analysis tools and advanced threat modeling tools. Includes intelligent
 * form generation based on tool schemas, parameter processing, and validation.
 */
class ToolsSection {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.tools = [];
        this.isLoading = false;
        this.hasError = false;
        this.errorMessage = '';
        
        // Tool categories for proper separation
        this.basicToolNames = [
            'search_attack',
            'get_technique', 
            'list_tactics',
            'get_group_techniques',
            'get_technique_mitigations'
        ];
        
        this.advancedToolNames = [
            'build_attack_path',
            'analyze_coverage_gaps', 
            'detect_technique_relationships'
        ];
        
        if (!this.container) {
            throw new Error(`Container element with ID '${containerId}' not found`);
        }
    }
    
    /**
     * Render the tools section with all forms
     */
    async render() {
        try {
            this.isLoading = true;
            this.hasError = false;
            this.renderLoadingState();
            
            // Fetch tools information
            this.tools = await api.getTools();
            
            this.isLoading = false;
            this.renderToolsSection();
            this.setupEventListeners();
            
        } catch (error) {
            console.error('Failed to render tools section:', error);
            this.isLoading = false;
            this.hasError = true;
            this.errorMessage = error.message || 'Failed to load tools';
            this.renderError();
        }
    }
    
    /**
     * Render loading state
     */
    renderLoadingState() {
        this.container.innerHTML = `
            <div class="tools-section-loading">
                <div class="row">
                    <div class="col-md-6">
                        <div class="card">
                            <div class="card-header">
                                <div class="loading-skeleton" style="height: 1.5rem; width: 180px;"></div>
                            </div>
                            <div class="card-body">
                                <div class="loading-skeleton mb-3" style="height: 4rem;"></div>
                                <div class="loading-skeleton mb-3" style="height: 4rem;"></div>
                                <div class="loading-skeleton" style="height: 4rem;"></div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card">
                            <div class="card-header">
                                <div class="loading-skeleton" style="height: 1.5rem; width: 220px;"></div>
                            </div>
                            <div class="card-body">
                                <div class="loading-skeleton mb-3" style="height: 4rem;"></div>
                                <div class="loading-skeleton mb-3" style="height: 4rem;"></div>
                                <div class="loading-skeleton" style="height: 4rem;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    /**
     * Render error state
     */
    renderError() {
        this.container.innerHTML = `
            <div class="alert alert-danger" role="alert">
                <div class="d-flex align-items-center mb-2">
                    <i class="bi bi-exclamation-triangle-fill me-2"></i>
                    <strong>Failed to Load Tools</strong>
                </div>
                <p class="mb-3">${this.errorMessage}</p>
                <button type="button" class="btn btn-outline-danger" id="retry-tools">
                    <i class="bi bi-arrow-clockwise me-1"></i>
                    Retry
                </button>
            </div>
        `;
        
        // Setup retry button
        document.getElementById('retry-tools').addEventListener('click', () => {
            this.render();
        });
    }
    
    /**
     * Render the complete tools section
     */
    renderToolsSection() {
        const basicTools = this.tools.filter(tool => this.basicToolNames.includes(tool.name));
        const advancedTools = this.tools.filter(tool => this.advancedToolNames.includes(tool.name));
        
        this.container.innerHTML = `
            <div class="tools-section">
                <div class="row">
                    <!-- Basic Analysis Tools -->
                    <div class="col-lg-6 mb-4">
                        <div class="card h-100">
                            <div class="card-header bg-primary text-white">
                                <h5 class="card-title mb-0">
                                    <i class="bi bi-search me-2"></i>
                                    Basic Analysis Tools
                                </h5>
                                <small class="opacity-75">Fundamental threat intelligence queries</small>
                            </div>
                            <div class="card-body">
                                ${this.renderToolsGroup(basicTools)}
                            </div>
                        </div>
                    </div>
                    
                    <!-- Advanced Threat Modeling Tools -->
                    <div class="col-lg-6 mb-4">
                        <div class="card h-100">
                            <div class="card-header bg-success text-white">
                                <h5 class="card-title mb-0">
                                    <i class="bi bi-diagram-3 me-2"></i>
                                    Advanced Threat Modeling
                                </h5>
                                <small class="opacity-75">Complex analysis and relationship discovery</small>
                            </div>
                            <div class="card-body">
                                ${this.renderToolsGroup(advancedTools)}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    /**
     * Render a group of tools
     */
    renderToolsGroup(tools) {
        if (!tools || tools.length === 0) {
            return '<p class="text-muted">No tools available</p>';
        }
        
        return tools.map(tool => this.renderToolForm(tool)).join('');
    }
    
    /**
     * Render a single tool form
     */
    renderToolForm(tool) {
        const toolId = `tool-${tool.name}`;
        const isAdvanced = this.advancedToolNames.includes(tool.name);
        
        return `
            <div class="tool-form-container mb-4 pb-4 border-bottom">
                <div class="tool-header mb-3">
                    <h6 class="tool-title">
                        ${this.getToolIcon(tool.name)} ${this.formatToolName(tool.name)}
                        ${isAdvanced ? '<span class="badge bg-warning text-dark ms-2">Advanced</span>' : ''}
                    </h6>
                    <p class="tool-description text-muted small mb-2">
                        ${tool.description || 'No description available'}
                    </p>
                </div>
                
                <form class="tool-form" data-tool="${tool.name}" id="${toolId}">
                    ${this.generateFormFields(tool)}
                    <div class="form-actions mt-3">
                        <button type="submit" class="btn btn-primary btn-sm">
                            <i class="bi bi-play-fill me-1"></i>
                            Execute
                        </button>
                        <button type="reset" class="btn btn-outline-secondary btn-sm ms-2">
                            <i class="bi bi-arrow-clockwise me-1"></i>
                            Reset
                        </button>
                    </div>
                </form>
            </div>
        `;
    }
    
    /**
     * Generate form fields based on tool schema
     */
    generateFormFields(tool) {
        if (!tool.inputSchema || !tool.inputSchema.properties) {
            return '<p class="text-muted small">No parameters required</p>';
        }
        
        const properties = tool.inputSchema.properties;
        const required = tool.inputSchema.required || [];
        
        return Object.entries(properties).map(([key, prop]) => {
            const isRequired = required.includes(key);
            const fieldId = `${tool.name}-${key}`;
            
            return `
                <div class="mb-3">
                    <label for="${fieldId}" class="form-label">
                        ${this.formatFieldLabel(key)}
                        ${isRequired ? '<span class="text-danger">*</span>' : ''}
                    </label>
                    ${this.generateInputField(fieldId, key, prop, tool.name)}
                    ${prop.description ? `<div class="form-text">${prop.description}</div>` : ''}
                </div>
            `;
        }).join('');
    }
    
    /**
     * Generate appropriate input field based on property type
     */
    generateInputField(fieldId, key, prop, toolName) {
        const baseClasses = 'form-control';
        const smartControl = this.getSmartControlType(key);
        const classes = smartControl ? `${baseClasses} ${smartControl}` : baseClasses;
        
        // Check if field is required based on the tool schema
        const tool = this.tools.find(t => t.name === toolName);
        const isRequired = tool?.inputSchema?.required?.includes(key) || false;
        const requiredAttr = isRequired ? 'required' : '';
        
        if (prop.type === 'array') {
            return `
                <textarea 
                    class="${classes}" 
                    id="${fieldId}" 
                    name="${key}" 
                    rows="3" 
                    placeholder="Enter values separated by commas or new lines"
                    data-type="array"
                    ${requiredAttr}
                ></textarea>
            `;
        } else if (prop.enum && prop.enum.length > 0) {
            const options = prop.enum.map(value => 
                `<option value="${value}">${value}</option>`
            ).join('');
            return `
                <select class="form-select ${smartControl || ''}" id="${fieldId}" name="${key}" ${requiredAttr}>
                    <option value="">Select an option...</option>
                    ${options}
                </select>
            `;
        } else if (smartControl === 'technique-autocomplete') {
            // Technique fields should be input elements for autocomplete, not selects
            return `
                <input 
                    type="text" 
                    class="${classes}" 
                    id="${fieldId}" 
                    name="${key}" 
                    placeholder="${prop.description || 'Start typing technique name or ID...'}"
                    data-smart-control="technique"
                    ${requiredAttr}
                >
            `;
        } else if (smartControl) {
            return `
                <select class="form-select ${smartControl}" id="${fieldId}" name="${key}" data-smart-control="${smartControl.replace('-select', '')}" ${requiredAttr}>
                    <option value="">Select...</option>
                </select>
            `;
        } else if (prop.type === 'boolean') {
            return `
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="${fieldId}" name="${key}" ${requiredAttr}>
                    <label class="form-check-label" for="${fieldId}">
                        Enable
                    </label>
                </div>
            `;
        } else if (prop.type === 'number' || prop.type === 'integer') {
            return `
                <input 
                    type="number" 
                    class="${classes}" 
                    id="${fieldId}" 
                    name="${key}" 
                    placeholder="${prop.description || 'Enter a number'}"
                    ${prop.minimum ? `min="${prop.minimum}"` : ''}
                    ${prop.maximum ? `max="${prop.maximum}"` : ''}
                    ${requiredAttr}
                >
            `;
        } else {
            return `
                <input 
                    type="text" 
                    class="${classes}" 
                    id="${fieldId}" 
                    name="${key}" 
                    placeholder="${prop.description || 'Enter value'}"
                    ${requiredAttr}
                >
            `;
        }
    }
    
    /**
     * Get smart control type for field names
     */
    getSmartControlType(fieldName) {
        const lowerField = fieldName.toLowerCase();
        
        if (lowerField.includes('group')) {
            return 'group-select';
        } else if (lowerField.includes('tactic')) {
            return 'tactic-select';
        } else if (lowerField.includes('technique')) {
            return 'technique-autocomplete';
        }
        
        return null;
    }
    
    /**
     * Get appropriate icon for tool
     */
    getToolIcon(toolName) {
        const icons = {
            'search_attack': '<i class="bi bi-search"></i>',
            'get_technique': '<i class="bi bi-bullseye"></i>',
            'list_tactics': '<i class="bi bi-list-ul"></i>',
            'get_group_techniques': '<i class="bi bi-people-fill"></i>',
            'get_technique_mitigations': '<i class="bi bi-shield-check"></i>',
            'build_attack_path': '<i class="bi bi-diagram-2"></i>',
            'analyze_coverage_gaps': '<i class="bi bi-graph-up-arrow"></i>',
            'detect_technique_relationships': '<i class="bi bi-bezier2"></i>'
        };
        
        return icons[toolName] || '<i class="bi bi-gear"></i>';
    }
    
    /**
     * Format tool name for display
     */
    formatToolName(toolName) {
        return toolName
            .replace(/_/g, ' ')
            .replace(/\b\w/g, l => l.toUpperCase());
    }
    
    /**
     * Format field label for display
     */
    formatFieldLabel(key) {
        return key
            .replace(/_/g, ' ')
            .replace(/\b\w/g, l => l.toUpperCase());
    }
    
    /**
     * Setup event listeners for form interactions
     */
    setupEventListeners() {
        const forms = this.container.querySelectorAll('.tool-form');
        
        forms.forEach(form => {
            // Form submission
            form.addEventListener('submit', this.handleFormSubmit.bind(this));
            
            // Form reset
            form.addEventListener('reset', this.handleFormReset.bind(this));
            
            // Real-time validation
            const inputs = form.querySelectorAll('input, select, textarea');
            inputs.forEach(input => {
                input.addEventListener('blur', () => this.validateField(input));
                input.addEventListener('input', () => {
                    if (input.classList.contains('is-invalid')) {
                        this.validateField(input);
                    }
                });
            });
        });
    }
    
    /**
     * Handle form submission
     */
    async handleFormSubmit(event) {
        event.preventDefault();
        
        const form = event.target;
        const toolName = form.dataset.tool;
        const submitBtn = form.querySelector('button[type="submit"]');
        const originalBtnContent = submitBtn.innerHTML;
        
        try {
            // Validate form
            if (!this.validateForm(form)) {
                return;
            }
            
            // Show loading state
            this.setFormLoading(form, true);
            submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Executing...';
            submitBtn.disabled = true;
            
            // Collect and process parameters
            const parameters = this.collectFormParameters(form);
            
            // Call tool via API
            const result = await api.callTool(toolName, parameters);
            
            // Display result
            if (window.resultsSection) {
                window.resultsSection.displayResult(result, toolName);
            } else {
                console.log('Tool result:', result);
            }
            
            // Show success feedback
            this.showToast('Success', `${this.formatToolName(toolName)} executed successfully`, 'success');
            
        } catch (error) {
            console.error(`Tool execution failed:`, error);
            
            // Display error
            if (window.resultsSection) {
                window.resultsSection.displayError(`${this.formatToolName(toolName)}: ${error.message}`);
            }
            
            this.showToast('Error', `Failed to execute ${this.formatToolName(toolName)}: ${error.message}`, 'danger');
            
        } finally {
            // Reset loading state
            this.setFormLoading(form, false);
            submitBtn.innerHTML = originalBtnContent;
            submitBtn.disabled = false;
        }
    }
    
    /**
     * Handle form reset
     */
    handleFormReset(event) {
        const form = event.target;
        
        setTimeout(() => {
            // Clear validation states
            const fields = form.querySelectorAll('.form-control, .form-select');
            fields.forEach(field => {
                field.classList.remove('is-valid', 'is-invalid');
            });
            
            // Remove validation feedback
            const feedbacks = form.querySelectorAll('.invalid-feedback, .valid-feedback');
            feedbacks.forEach(feedback => feedback.remove());
            
            form.classList.remove('was-validated');
        }, 10);
    }
    
    /**
     * Collect and process form parameters
     */
    collectFormParameters(form) {
        const parameters = {};
        
        // Get all form fields 
        const allFields = form.querySelectorAll('input, select, textarea');
        
        allFields.forEach(field => {
            const key = field.name;
            
            if (!key) {
                return; // Skip fields without names
            }
            
            if (field.type === 'checkbox') {
                // Always include checkbox values (true/false)
                parameters[key] = field.checked;
            } else {
                // Get field value and trim whitespace
                let value = field.value;
                
                if (value !== null && value !== undefined && value.trim() !== '') {
                    const dataType = field.dataset?.type;
                    
                    if (dataType === 'array') {
                        // Handle array fields (comma or newline separated)
                        parameters[key] = value.split(/[,\n]/)
                            .map(v => v.trim())
                            .filter(v => v.length > 0);
                    } else if (field.type === 'number') {
                        parameters[key] = parseFloat(value);
                    } else {
                        parameters[key] = value.trim();
                    }
                }
            }
        });
        
        return parameters;
    }
    
    /**
     * Validate form before submission
     */
    validateForm(form) {
        let isValid = true;
        const inputs = form.querySelectorAll('input, select, textarea');
        
        inputs.forEach(input => {
            if (!this.validateField(input)) {
                isValid = false;
            }
        });
        
        form.classList.add('was-validated');
        return isValid;
    }
    
    /**
     * Validate individual field
     */
    validateField(field) {
        const isRequired = field.hasAttribute('required') || 
                          field.labels?.[0]?.textContent?.includes('*');
        const value = field.type === 'checkbox' ? field.checked : field.value.trim();
        
        let isValid = true;
        let errorMessage = '';
        
        // Required field validation
        if (isRequired && !value) {
            isValid = false;
            errorMessage = 'This field is required';
        }
        
        // Type-specific validation
        if (value && field.dataset?.type === 'array') {
            const arrayValues = value.split(/[,\n]/).map(v => v.trim()).filter(v => v);
            if (arrayValues.length === 0) {
                isValid = false;
                errorMessage = 'Please provide at least one value';
            }
        }
        
        if (value && field.type === 'number') {
            const numValue = parseFloat(value);
            if (isNaN(numValue)) {
                isValid = false;
                errorMessage = 'Please enter a valid number';
            } else if (field.min && numValue < parseFloat(field.min)) {
                isValid = false;
                errorMessage = `Value must be at least ${field.min}`;
            } else if (field.max && numValue > parseFloat(field.max)) {
                isValid = false;
                errorMessage = `Value must be at most ${field.max}`;
            }
        }
        
        // Update field validation state
        this.updateFieldValidation(field, isValid, errorMessage);
        
        return isValid;
    }
    
    /**
     * Update field validation visual state
     */
    updateFieldValidation(field, isValid, errorMessage) {
        // Remove existing validation classes
        field.classList.remove('is-valid', 'is-invalid');
        
        // Add appropriate class
        if (field.value.trim() || field.type === 'checkbox') {
            field.classList.add(isValid ? 'is-valid' : 'is-invalid');
        }
        
        // Update feedback message
        this.updateValidationFeedback(field, errorMessage, isValid);
    }
    
    /**
     * Update validation feedback message
     */
    updateValidationFeedback(field, message, isValid) {
        // Remove existing feedback
        const existingFeedback = field.parentElement.querySelector('.invalid-feedback, .valid-feedback');
        if (existingFeedback) {
            existingFeedback.remove();
        }
        
        if (!isValid && message) {
            const feedback = document.createElement('div');
            feedback.className = 'invalid-feedback';
            feedback.textContent = message;
            field.parentElement.appendChild(feedback);
        }
    }
    
    /**
     * Set form loading state
     */
    setFormLoading(form, isLoading) {
        const fields = form.querySelectorAll('input, select, textarea, button');
        
        fields.forEach(field => {
            if (isLoading) {
                field.disabled = true;
                if (field.type !== 'submit') {
                    field.style.opacity = '0.6';
                }
            } else {
                field.disabled = false;
                field.style.opacity = '';
            }
        });
        
        if (isLoading) {
            form.classList.add('loading');
        } else {
            form.classList.remove('loading');
        }
    }
    
    /**
     * Show toast notification
     */
    showToast(title, message, type = 'info') {
        // Create toast container if it doesn't exist
        let container = document.querySelector('.toast-container');
        if (!container) {
            container = document.createElement('div');
            container.className = 'toast-container position-fixed top-0 end-0 p-3';
            document.body.appendChild(container);
        }
        
        // Create toast
        const toast = document.createElement('div');
        toast.className = `toast align-items-center text-white bg-${type} border-0`;
        toast.setAttribute('role', 'alert');
        toast.innerHTML = `
            <div class="d-flex">
                <div class="toast-body">
                    <strong>${title}:</strong> ${message}
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
            </div>
        `;
        
        container.appendChild(toast);
        
        // Show toast
        const bsToast = new bootstrap.Toast(toast, { delay: 4000 });
        bsToast.show();
        
        // Remove from DOM after hiding
        toast.addEventListener('hidden.bs.toast', () => {
            toast.remove();
        });
    }
    
    /**
     * Get tools data
     */
    getTools() {
        return this.tools;
    }
    
    /**
     * Check if tools section is loading
     */
    isLoadingTools() {
        return this.isLoading;
    }
    
    /**
     * Check if tools section has error
     */
    hasErrorState() {
        return this.hasError;
    }
    
    /**
     * Refresh tools section
     */
    async refresh() {
        await this.render();
    }
    
    /**
     * Destroy and cleanup
     */
    destroy() {
        if (this.container) {
            this.container.innerHTML = '';
        }
    }
}

/**
 * Results Section Component
 * 
 * Professional results display system with responsive output area, syntax highlighting,
 * copy/download functionality, timestamp display, error handling, and toast notifications.
 */
class ResultsSection {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.currentResult = null;
        this.resultHistory = [];
        this.maxHistorySize = 10;
        
        if (!this.container) {
            throw new Error(`Container element with ID '${containerId}' not found`);
        }
        
        // Make instance globally available for tool forms
        window.resultsSection = this;
        
        this.render();
    }
    
    /**
     * Initial render of results section
     */
    render() {
        this.container.innerHTML = `
            <div class="results-section">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="card-title mb-0">
                            <i class="bi bi-terminal me-2"></i>
                            Analysis Results
                        </h5>
                        <div class="btn-toolbar" role="toolbar">
                            <div class="btn-group me-2" role="group">
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="copy-result" title="Copy to clipboard">
                                    <i class="bi bi-clipboard"></i>
                                </button>
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="download-result" title="Download as file">
                                    <i class="bi bi-download"></i>
                                </button>
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="clear-result" title="Clear results">
                                    <i class="bi bi-trash"></i>
                                </button>
                            </div>
                            <div class="btn-group" role="group">
                                <button type="button" class="btn btn-outline-info btn-sm" id="toggle-history" title="Show history">
                                    <i class="bi bi-clock-history"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="card-body p-0">
                        <div class="output-area" id="output-area">
                            ${this.getPlaceholderContent()}
                        </div>
                    </div>
                </div>
                
                <!-- History Panel (Initially Hidden) -->
                <div class="card mt-3" id="history-panel" style="display: none;">
                    <div class="card-header">
                        <h6 class="card-title mb-0">
                            <i class="bi bi-clock-history me-2"></i>
                            Result History
                        </h6>
                    </div>
                    <div class="card-body" id="history-content">
                        <p class="text-muted">No previous results</p>
                    </div>
                </div>
            </div>
        `;
        
        this.setupEventListeners();
    }
    
    /**
     * Get placeholder content for empty state
     */
    getPlaceholderContent() {
        return `
            <div class="output-placeholder d-flex flex-column align-items-center justify-content-center py-5">
                <i class="bi bi-terminal display-1 text-muted mb-3"></i>
                <h6 class="text-muted mb-2">Ready for Analysis</h6>
                <p class="text-muted text-center">
                    Execute any tool above to see results here.<br>
                    Results will be formatted with syntax highlighting and timestamps.
                </p>
            </div>
        `;
    }
    
    /**
     * Setup event listeners for result actions
     */
    setupEventListeners() {
        // Copy button
        document.getElementById('copy-result').addEventListener('click', () => {
            this.copyToClipboard();
        });
        
        // Download button  
        document.getElementById('download-result').addEventListener('click', () => {
            this.downloadResult();
        });
        
        // Clear button
        document.getElementById('clear-result').addEventListener('click', () => {
            this.clearResults();
        });
        
        // History toggle
        document.getElementById('toggle-history').addEventListener('click', () => {
            this.toggleHistory();
        });
    }
    
    /**
     * Display a successful result
     */
    displayResult(result, toolName, timestamp = null) {
        const resultTimestamp = timestamp || new Date();
        
        // Store in history
        this.addToHistory(result, toolName, resultTimestamp);
        
        // Update current result
        this.currentResult = {
            data: result,
            toolName: toolName,
            timestamp: resultTimestamp,
            type: 'success'
        };
        
        // Render result
        const outputArea = document.getElementById('output-area');
        outputArea.innerHTML = this.getResultTemplate(result, toolName, resultTimestamp, 'success');
        
        // Enable action buttons
        this.updateActionButtons(true);
        
        // Scroll to results
        this.scrollToResults();
        
        // Show success toast
        this.showToast('Success', `${toolName} completed successfully`, 'success');
    }
    
    /**
     * Display an error result
     */
    displayError(error, toolName = null, timestamp = null) {
        const resultTimestamp = timestamp || new Date();
        const errorMessage = typeof error === 'string' ? error : error.message || 'Unknown error occurred';
        
        // Store in history
        this.addToHistory(errorMessage, toolName || 'Error', resultTimestamp, 'error');
        
        // Update current result
        this.currentResult = {
            data: errorMessage,
            toolName: toolName || 'Error',
            timestamp: resultTimestamp,
            type: 'error'
        };
        
        // Render error
        const outputArea = document.getElementById('output-area');
        outputArea.innerHTML = this.getErrorTemplate(errorMessage, toolName, resultTimestamp);
        
        // Enable action buttons
        this.updateActionButtons(true);
        
        // Scroll to results
        this.scrollToResults();
        
        // Show error toast
        this.showToast('Error', errorMessage, 'danger');
    }
    
    /**
     * Get result template for successful results
     */
    getResultTemplate(result, toolName, timestamp, type) {
        const formattedTimestamp = this.formatTimestamp(timestamp);
        const statusBadge = type === 'error' ? 'danger' : 'success';
        const statusIcon = type === 'error' ? 'bi-exclamation-triangle' : 'bi-check-circle';
        
        return `
            <div class="result-content">
                <div class="result-header p-3 bg-light border-bottom">
                    <div class="d-flex justify-content-between align-items-center">
                        <div class="d-flex align-items-center">
                            <span class="badge bg-${statusBadge} me-2">
                                <i class="bi ${statusIcon} me-1"></i>
                                ${toolName}
                            </span>
                            <span class="text-muted small">
                                <i class="bi bi-clock me-1"></i>
                                ${formattedTimestamp}
                            </span>
                        </div>
                        <div class="result-stats text-muted small">
                            ${this.getResultStats(result)}
                        </div>
                    </div>
                </div>
                <div class="result-body">
                    ${type === 'error' ? 
                        `<div class="alert alert-danger m-3"><pre><code>${this.formatResult(result)}</code></pre></div>` : 
                        this.parseAndFormatResult(result, toolName)
                    }
                </div>
            </div>
        `;
    }
    
    /**
     * Parse and format result with collapsible sections and MITRE links
     */
    parseAndFormatResult(result, toolName) {
        try {
            // Split result into sections
            const sections = this.parseResultSections(result);
            
            if (sections.length <= 1) {
                // Simple result - no sections found, display as enhanced single block
                return this.formatSimpleResult(result);
            }
            
            // Multi-section result - create accordion
            return this.createAccordionResult(sections, toolName);
            
        } catch (error) {
            console.error('Error parsing result:', error);
            // Fallback to simple formatting
            return `<div class="alert alert-warning m-3">
                <h6>Result (Parsing Error)</h6>
                <pre class="mt-2"><code>${this.escapeHtml(result)}</code></pre>
            </div>`;
        }
    }

    /**
     * Parse result text into logical sections with enhanced intelligence
     */
    parseResultSections(result) {
        const text = String(result).trim();
        const sections = [];
        
        // Enhanced section patterns with capture groups for better parsing
        const sectionPatterns = [
            // Headers with underlines (GROUP TECHNIQUES, TECHNIQUE DETAILS, etc.)
            {
                pattern: /^([A-Z][A-Z\s&'-]+)$\n^={4,}$/gm,
                type: 'header'
            },
            // Numbered technique/item entries (1. T1055: Process Injection)
            {
                pattern: /^(\d+\.\s+([A-Z]\d+(?:\.\d+)?):?\s*([^:\n]+))(?::(.*))?$/gm,
                type: 'numbered_item'
            },
            // Technique entries without numbers (T1055: Process Injection)
            {
                pattern: /^(([A-Z]\d+(?:\.\d+)?):?\s*([^:\n]+)):?$/gm,
                type: 'technique_item'
            },
            // Field labels (Description:, Techniques Used:, etc.)
            {
                pattern: /^(Description|Techniques Used|Aliases|Mitigations|Platforms|Tactics|Groups):/gim,
                type: 'field'
            }
        ];
        
        const sectionBoundaries = [];
        
        // Find all section boundaries with enhanced information
        sectionPatterns.forEach(patternObj => {
            let match;
            const pattern = patternObj.pattern;
            while ((match = pattern.exec(text)) !== null) {
                const boundary = {
                    start: match.index,
                    title: match[1].trim(),
                    titleEnd: match.index + match[0].length,
                    type: patternObj.type,
                    rawMatch: match
                };
                
                // Extract enhanced information based on type
                if (patternObj.type === 'numbered_item' || patternObj.type === 'technique_item') {
                    boundary.mitre_id = match[2]; // T1055
                    boundary.technique_name = match[3] ? match[3].trim() : ''; // Process Injection
                    if (match[4]) {
                        boundary.description = match[4].trim();
                    }
                }
                
                sectionBoundaries.push(boundary);
            }
        });
        
        // Sort boundaries by position
        sectionBoundaries.sort((a, b) => a.start - b.start);
        
        if (sectionBoundaries.length === 0) {
            return [{ 
                title: 'Result', 
                content: text,
                enhancedTitle: this.extractMainTitle(text)
            }];
        }
        
        // Create sections with enhanced titles
        for (let i = 0; i < sectionBoundaries.length; i++) {
            const boundary = sectionBoundaries[i];
            const nextBoundary = sectionBoundaries[i + 1];
            
            const sectionStart = boundary.titleEnd;
            const sectionEnd = nextBoundary ? nextBoundary.start : text.length;
            const content = text.substring(sectionStart, sectionEnd).trim();
            
            if (content || boundary.type === 'header') {
                const section = {
                    title: boundary.title,
                    content: content,
                    type: boundary.type,
                    enhancedTitle: this.createEnhancedTitle(boundary, content)
                };
                
                // Add MITRE identifier info if available
                if (boundary.mitre_id) {
                    section.mitre_id = boundary.mitre_id;
                    section.technique_name = boundary.technique_name;
                }
                
                sections.push(section);
            }
        }
        
        return sections;
    }

    /**
     * Extract main title from text for simple results
     */
    extractMainTitle(text) {
        const lines = text.split('\n');
        
        // Look for header patterns
        for (let i = 0; i < Math.min(lines.length, 5); i++) {
            const line = lines[i].trim();
            
            // Group name pattern
            const groupMatch = line.match(/^Group Name:\s*(.+)$/);
            if (groupMatch) {
                return groupMatch[1];
            }
            
            // Technique name pattern  
            const techMatch = line.match(/^Name:\s*(.+)$/);
            if (techMatch) {
                return techMatch[1];
            }
            
            // ID and name pattern
            const idNameMatch = line.match(/^(ID|Name):\s*([A-Z]\d+(?:\.\d+)?)\s*-?\s*(.*)$/);
            if (idNameMatch) {
                return idNameMatch[3] || idNameMatch[2];
            }
        }
        
        return 'Result';
    }

    /**
     * Create enhanced title for accordion headers
     */
    createEnhancedTitle(boundary, content) {
        if (boundary.type === 'numbered_item' || boundary.type === 'technique_item') {
            // For technique entries: "T1055: Process Injection"
            if (boundary.mitre_id && boundary.technique_name) {
                return `${boundary.mitre_id}: ${boundary.technique_name}`;
            }
        }
        
        if (boundary.type === 'header') {
            // For headers, try to extract meaningful context from content
            const contextInfo = this.extractContextFromContent(content);
            if (contextInfo) {
                return `${boundary.title} - ${contextInfo}`;
            }
        }
        
        if (boundary.type === 'field') {
            // For fields, try to extract key information
            const summary = this.extractFieldSummary(boundary.title, content);
            if (summary) {
                return `${boundary.title} (${summary})`;
            }
        }
        
        return boundary.title;
    }

    /**
     * Extract context information from content
     */
    extractContextFromContent(content) {
        const lines = content.split('\n').map(line => line.trim()).filter(line => line);
        
        // Look for group name
        for (const line of lines.slice(0, 5)) {
            const groupMatch = line.match(/^Group Name:\s*(.+)$/);
            if (groupMatch) {
                return groupMatch[1];
            }
            
            const nameMatch = line.match(/^Name:\s*(.+)$/);
            if (nameMatch) {
                return nameMatch[1];
            }
        }
        
        // Look for counts in parentheses
        const countMatch = content.match(/\((\d+)\):/);
        if (countMatch) {
            return `${countMatch[1]} items`;
        }
        
        return null;
    }

    /**
     * Extract summary for field sections
     */
    extractFieldSummary(fieldTitle, content) {
        const lines = content.split('\n').filter(line => line.trim());
        
        if (fieldTitle.toLowerCase().includes('techniques')) {
            const countMatch = content.match(/\((\d+)\)/);
            if (countMatch) {
                return `${countMatch[1]} techniques`;
            }
        }
        
        if (fieldTitle.toLowerCase() === 'platforms' && lines.length > 0) {
            const platforms = lines[0].split(',').map(p => p.trim());
            return platforms.slice(0, 3).join(', ') + (platforms.length > 3 ? '...' : '');
        }
        
        if (fieldTitle.toLowerCase() === 'tactics' && lines.length > 0) {
            const tactics = lines.filter(line => line.includes('TA'));
            return `${tactics.length} tactics`;
        }
        
        return null;
    }

    /**
     * Create accordion-style result display with smart expansion
     */
    createAccordionResult(sections, toolName) {
        const accordionId = `accordion-${Date.now()}`;
        
        // Calculate smart expansion - expand all if total content is small enough
        const expansionConfig = this.calculateSmartExpansion(sections);
        
        const accordionItems = sections.map((section, index) => {
            const itemId = `${accordionId}-item-${index}`;
            const shouldExpand = expansionConfig.expandedItems.includes(index);
            
            // Use enhanced title if available, fallback to original title
            const displayTitle = section.enhancedTitle || section.title;
            
            return `
                <div class="accordion-item" data-section-type="${section.type || 'default'}">
                    <h2 class="accordion-header">
                        <button class="accordion-button ${shouldExpand ? '' : 'collapsed'}" type="button" 
                                data-bs-toggle="collapse" data-bs-target="#${itemId}" 
                                aria-expanded="${shouldExpand}" aria-controls="${itemId}">
                            <div class="accordion-title-content">
                                <div class="accordion-main-title">
                                    <strong>${this.escapeHtml(displayTitle)}</strong>
                                </div>
                                ${this.createAccordionSubtitle(section)}
                            </div>
                            ${this.getSectionBadge(section)}
                        </button>
                    </h2>
                    <div id="${itemId}" class="accordion-collapse collapse ${shouldExpand ? 'show' : ''}" 
                         data-bs-parent="#${accordionId}">
                        <div class="accordion-body">
                            ${this.formatSectionContent(section.content)}
                        </div>
                    </div>
                </div>
            `;
        }).join('');
        
        return `
            <div class="accordion accordion-smart" id="${accordionId}" data-expansion-mode="${expansionConfig.mode}">
                <div class="accordion-info text-muted small mb-2">
                    ${expansionConfig.info}
                </div>
                ${accordionItems}
            </div>
        `;
    }

    /**
     * Calculate smart expansion logic
     */
    calculateSmartExpansion(sections) {
        const totalContentLength = sections.reduce((sum, section) => sum + section.content.length, 0);
        const averageContentLength = totalContentLength / sections.length;
        const viewportHeight = window.innerHeight || 800;
        const estimatedItemHeight = 120; // Base height per accordion item
        const availableHeight = viewportHeight * 0.6; // Use 60% of viewport
        
        // Calculate how many items can fit expanded
        const maxExpandableItems = Math.floor(availableHeight / (estimatedItemHeight + averageContentLength / 5));
        
        let mode, expandedItems, info;
        
        if (sections.length <= 3 && totalContentLength < 2000) {
            // Small result set - expand all
            mode = 'expand_all';
            expandedItems = sections.map((_, index) => index);
            info = `All ${sections.length} sections expanded (compact result)`;
        } else if (maxExpandableItems >= sections.length) {
            // Content fits - expand all
            mode = 'expand_all';
            expandedItems = sections.map((_, index) => index);
            info = `All ${sections.length} sections expanded (fits in view)`;
        } else if (maxExpandableItems >= 2) {
            // Expand first few sections
            mode = 'expand_first';
            expandedItems = Array.from({length: Math.min(maxExpandableItems, sections.length)}, (_, i) => i);
            info = `First ${expandedItems.length} of ${sections.length} sections expanded`;
        } else {
            // Large content - expand only first
            mode = 'expand_first_only';
            expandedItems = [0];
            info = `First section expanded (${sections.length} sections total)`;
        }
        
        return { mode, expandedItems, info };
    }

    /**
     * Create subtitle for accordion headers
     */
    createAccordionSubtitle(section) {
        if (section.type === 'numbered_item' && section.mitre_id) {
            // Extract tactic information from content
            const tacticMatch = section.content.match(/Tactics?:\s*([^\n]+)/i);
            if (tacticMatch) {
                const tactics = tacticMatch[1].split(',').map(t => t.trim()).slice(0, 2);
                return `<div class="accordion-subtitle text-muted">${tactics.join(', ')}</div>`;
            }
        }
        
        if (section.type === 'header' && section.content) {
            // For headers, show a preview of key information
            const lines = section.content.split('\n').slice(0, 3);
            const preview = lines.find(line => 
                line.includes('Group Name:') || 
                line.includes('Name:') || 
                line.includes('ID:')
            );
            if (preview) {
                const cleanPreview = preview.replace(/^[^:]*:\s*/, '').substring(0, 50);
                if (cleanPreview) {
                    return `<div class="accordion-subtitle text-muted">${this.escapeHtml(cleanPreview)}</div>`;
                }
            }
        }
        
        return '';
    }

    /**
     * Format simple result (no sections)
     */
    formatSimpleResult(result) {
        return `
            <div class="card m-3">
                <div class="card-body">
                    <div class="formatted-content">
                        ${this.formatSectionContent(result)}
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Format section content with MITRE links and enhanced formatting
     */
    formatSectionContent(content) {
        let formatted = this.escapeHtml(content);
        
        // Add MITRE deep links
        formatted = this.addMitreDeepLinks(formatted);
        
        // Format lists and structure
        formatted = this.formatTextStructure(formatted);
        
        return formatted;
    }

    /**
     * Add MITRE ATT&CK deep links to identifiers
     */
    addMitreDeepLinks(text) {
        // Group IDs (G0001-G9999)
        text = text.replace(/\b(G\d{4})\b/g, 
            '<a href="https://attack.mitre.org/groups/$1" target="_blank" class="mitre-link mitre-group">$1 <i class="bi bi-box-arrow-up-right"></i></a>');
        
        // Technique IDs (T1001, T1001.001)
        text = text.replace(/\b(T\d{4}(?:\.\d{3})?)\b/g, 
            '<a href="https://attack.mitre.org/techniques/$1" target="_blank" class="mitre-link mitre-technique">$1 <i class="bi bi-box-arrow-up-right"></i></a>');
        
        // Tactic IDs (TA0001-TA0043)  
        text = text.replace(/\b(TA\d{4})\b/g, 
            '<a href="https://attack.mitre.org/tactics/$1" target="_blank" class="mitre-link mitre-tactic">$1 <i class="bi bi-box-arrow-up-right"></i></a>');
        
        // Mitigation IDs (M1001-M1999)
        text = text.replace(/\b(M\d{4})\b/g, 
            '<a href="https://attack.mitre.org/mitigations/$1" target="_blank" class="mitre-link mitre-mitigation">$1 <i class="bi bi-box-arrow-up-right"></i></a>');
        
        // Software IDs (S0001-S9999) 
        text = text.replace(/\b(S\d{4})\b/g, 
            '<a href="https://attack.mitre.org/software/$1" target="_blank" class="mitre-link mitre-software">$1 <i class="bi bi-box-arrow-up-right"></i></a>');
        
        return text;
    }

    /**
     * Format text structure (lists, paragraphs, etc.)
     */
    formatTextStructure(text) {
        // Convert numbered lists to proper HTML lists
        let formatted = text.replace(/^(\d+\.\s+)(.+)$/gm, '<li><strong>$1</strong>$2</li>');
        if (formatted.includes('<li>')) {
            formatted = '<ol class="formatted-list">' + formatted.replace(/^(?!<li>)/gm, '') + '</ol>';
        }
        
        // Convert double newlines to paragraphs
        formatted = formatted.split('\n\n').map(para => {
            para = para.trim();
            if (para && !para.includes('<ol') && !para.includes('<li>')) {
                return `<p>${para.replace(/\n/g, '<br>')}</p>`;
            }
            return para;
        }).join('\n');
        
        // Format field labels (Description:, Platforms:, etc.)
        formatted = formatted.replace(/^([A-Z][a-z\s]+):(.+)$/gm, 
            '<div class="field-group"><span class="field-label">$1:</span><span class="field-value">$2</span></div>');
        
        return formatted;
    }

    /**
     * Get badge for section based on content
     */
    getSectionBadge(section) {
        const content = section.content.toLowerCase();
        let count = 0;
        let type = 'secondary';
        
        // Count techniques
        const techniqueMatches = section.content.match(/\bT\d{4}(?:\.\d{3})?\b/g);
        if (techniqueMatches) {
            count = techniqueMatches.length;
            type = 'primary';
        }
        
        // Count groups
        const groupMatches = section.content.match(/\bG\d{4}\b/g);
        if (groupMatches) {
            count = Math.max(count, groupMatches.length);
            type = 'success';
        }
        
        // Count mitigations
        const mitigationMatches = section.content.match(/\bM\d{4}\b/g);
        if (mitigationMatches) {
            count = Math.max(count, mitigationMatches.length);
            type = 'info';
        }
        
        if (count > 0) {
            return `<span class="badge bg-${type} ms-2">${count}</span>`;
        }
        
        return '';
    }

    /**
     * Escape HTML characters
     */
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Get error template
     */
    getErrorTemplate(error, toolName, timestamp) {
        const formattedTimestamp = this.formatTimestamp(timestamp);
        
        return `
            <div class="result-content">
                <div class="result-header p-3 bg-danger text-white">
                    <div class="d-flex justify-content-between align-items-center">
                        <div class="d-flex align-items-center">
                            <span class="badge bg-light text-danger me-2">
                                <i class="bi bi-exclamation-triangle me-1"></i>
                                ${toolName || 'Error'}
                            </span>
                            <span class="small opacity-75">
                                <i class="bi bi-clock me-1"></i>
                                ${formattedTimestamp}
                            </span>
                        </div>
                    </div>
                </div>
                <div class="result-body">
                    <div class="alert alert-danger m-3 mb-0">
                        <div class="d-flex align-items-start">
                            <i class="bi bi-exclamation-triangle-fill text-danger me-2 mt-1"></i>
                            <div>
                                <strong>Execution Failed</strong>
                                <div class="mt-2">${this.escapeHtml(error)}</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    /**
     * Format result data with syntax highlighting
     */
    formatResult(result) {
        let formatted;
        
        try {
            // Try to parse as JSON for pretty formatting
            let data;
            if (typeof result === 'string') {
                try {
                    data = JSON.parse(result);
                } catch {
                    data = result;
                }
            } else {
                data = result;
            }
            
            if (typeof data === 'object') {
                formatted = JSON.stringify(data, null, 2);
            } else {
                formatted = String(data);
            }
            
            // Apply basic syntax highlighting for JSON
            if (formatted.includes('{') || formatted.includes('[')) {
                formatted = this.applySyntaxHighlighting(formatted);
            }
            
        } catch (e) {
            formatted = String(result);
        }
        
        return formatted;
    }
    
    /**
     * Apply basic syntax highlighting to JSON
     */
    applySyntaxHighlighting(json) {
        return json
            .replace(/(".*?")\s*:/g, '<span class="json-key">$1</span>:') // Keys
            .replace(/:\s*(".*?")/g, ': <span class="json-string">$1</span>') // String values
            .replace(/:\s*(\d+\.?\d*)/g, ': <span class="json-number">$1</span>') // Numbers
            .replace(/:\s*(true|false|null)/g, ': <span class="json-boolean">$1</span>'); // Booleans/null
    }
    
    /**
     * Get statistics about the result
     */
    getResultStats(result) {
        try {
            const text = typeof result === 'string' ? result : JSON.stringify(result);
            const lines = text.split('\n').length;
            const chars = text.length;
            const size = new Blob([text]).size;
            
            return `${lines} lines  ${chars} characters  ${this.formatBytes(size)}`;
        } catch {
            return 'Result statistics unavailable';
        }
    }
    
    /**
     * Format timestamp for display
     */
    formatTimestamp(timestamp) {
        return timestamp.toLocaleString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
    }
    
    /**
     * Format bytes for display
     */
    formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }
    
    /**
     * Escape HTML to prevent XSS
     */
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    /**
     * Copy result to clipboard
     */
    async copyToClipboard() {
        if (!this.currentResult) {
            this.showToast('Info', 'No result to copy', 'info');
            return;
        }
        
        try {
            const textToCopy = typeof this.currentResult.data === 'string' 
                ? this.currentResult.data 
                : JSON.stringify(this.currentResult.data, null, 2);
            
            await navigator.clipboard.writeText(textToCopy);
            this.showToast('Success', 'Result copied to clipboard', 'success');
            
            // Visual feedback on button
            const copyBtn = document.getElementById('copy-result');
            const originalIcon = copyBtn.innerHTML;
            copyBtn.innerHTML = '<i class="bi bi-check"></i>';
            setTimeout(() => {
                copyBtn.innerHTML = originalIcon;
            }, 1000);
            
        } catch (error) {
            console.error('Failed to copy:', error);
            this.showToast('Error', 'Failed to copy to clipboard', 'danger');
        }
    }
    
    /**
     * Download result as file
     */
    downloadResult() {
        if (!this.currentResult) {
            this.showToast('Info', 'No result to download', 'info');
            return;
        }
        
        try {
            const content = typeof this.currentResult.data === 'string' 
                ? this.currentResult.data 
                : JSON.stringify(this.currentResult.data, null, 2);
            
            const blob = new Blob([content], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${this.currentResult.toolName}_${this.formatTimestamp(this.currentResult.timestamp).replace(/[/:,\s]/g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            
            this.showToast('Success', 'Result downloaded successfully', 'success');
            
        } catch (error) {
            console.error('Failed to download:', error);
            this.showToast('Error', 'Failed to download result', 'danger');
        }
    }
    
    /**
     * Clear all results
     */
    clearResults() {
        this.currentResult = null;
        
        const outputArea = document.getElementById('output-area');
        outputArea.innerHTML = this.getPlaceholderContent();
        
        // Disable action buttons
        this.updateActionButtons(false);
        
        // Hide history panel
        document.getElementById('history-panel').style.display = 'none';
        
        this.showToast('Info', 'Results cleared', 'info');
    }
    
    /**
     * Update action button states
     */
    updateActionButtons(enabled) {
        const buttons = ['copy-result', 'download-result'];
        buttons.forEach(id => {
            const btn = document.getElementById(id);
            btn.disabled = !enabled;
            if (enabled) {
                btn.classList.remove('disabled');
            } else {
                btn.classList.add('disabled');
            }
        });
    }
    
    /**
     * Add result to history
     */
    addToHistory(data, toolName, timestamp, type = 'success') {
        const historyItem = {
            data,
            toolName,
            timestamp,
            type,
            id: Date.now() + Math.random()
        };
        
        this.resultHistory.unshift(historyItem);
        
        // Limit history size
        if (this.resultHistory.length > this.maxHistorySize) {
            this.resultHistory = this.resultHistory.slice(0, this.maxHistorySize);
        }
        
        this.updateHistoryDisplay();
    }
    
    /**
     * Toggle history panel visibility
     */
    toggleHistory() {
        const panel = document.getElementById('history-panel');
        const btn = document.getElementById('toggle-history');
        
        if (panel.style.display === 'none') {
            panel.style.display = 'block';
            btn.innerHTML = '<i class="bi bi-eye-slash"></i>';
            btn.title = 'Hide history';
        } else {
            panel.style.display = 'none';
            btn.innerHTML = '<i class="bi bi-clock-history"></i>';
            btn.title = 'Show history';
        }
    }
    
    /**
     * Update history display
     */
    updateHistoryDisplay() {
        const historyContent = document.getElementById('history-content');
        
        if (this.resultHistory.length === 0) {
            historyContent.innerHTML = '<p class="text-muted">No previous results</p>';
            return;
        }
        
        const historyItems = this.resultHistory.map((item, index) => {
            const badge = item.type === 'error' ? 'danger' : 'success';
            const icon = item.type === 'error' ? 'bi-exclamation-triangle' : 'bi-check-circle';
            
            return `
                <div class="history-item border rounded p-2 mb-2 ${item.type === 'error' ? 'border-danger' : ''}" data-id="${item.id}">
                    <div class="d-flex justify-content-between align-items-center mb-1">
                        <span class="badge bg-${badge}">
                            <i class="bi ${icon} me-1"></i>
                            ${item.toolName}
                        </span>
                        <small class="text-muted">${this.formatTimestamp(item.timestamp)}</small>
                    </div>
                    <div class="history-preview small text-muted" style="max-height: 60px; overflow: hidden;">
                        ${this.getHistoryPreview(item.data)}
                    </div>
                    <div class="mt-1">
                        <button class="btn btn-sm btn-outline-secondary" onclick="resultsSection.restoreFromHistory('${item.id}')">
                            <i class="bi bi-arrow-up-square"></i> Restore
                        </button>
                    </div>
                </div>
            `;
        }).join('');
        
        historyContent.innerHTML = historyItems;
    }
    
    /**
     * Get preview text for history item
     */
    getHistoryPreview(data) {
        const text = typeof data === 'string' ? data : JSON.stringify(data);
        const preview = text.substring(0, 100);
        return this.escapeHtml(preview) + (text.length > 100 ? '...' : '');
    }
    
    /**
     * Restore result from history
     */
    restoreFromHistory(historyId) {
        const historyItem = this.resultHistory.find(item => item.id == historyId);
        if (!historyItem) return;
        
        if (historyItem.type === 'error') {
            this.displayError(historyItem.data, historyItem.toolName, historyItem.timestamp);
        } else {
            this.displayResult(historyItem.data, historyItem.toolName, historyItem.timestamp);
        }
        
        this.showToast('Info', 'Result restored from history', 'info');
    }
    
    /**
     * Scroll to results area
     */
    scrollToResults() {
        this.container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
    
    /**
     * Show toast notification
     */
    showToast(title, message, type = 'info') {
        // Create toast container if it doesn't exist
        let container = document.querySelector('.toast-container');
        if (!container) {
            container = document.createElement('div');
            container.className = 'toast-container position-fixed top-0 end-0 p-3';
            container.style.zIndex = '9999';
            document.body.appendChild(container);
        }
        
        // Create toast
        const toast = document.createElement('div');
        toast.className = `toast align-items-center text-white bg-${type} border-0`;
        toast.setAttribute('role', 'alert');
        toast.innerHTML = `
            <div class="d-flex">
                <div class="toast-body">
                    <strong>${title}:</strong> ${message}
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
            </div>
        `;
        
        container.appendChild(toast);
        
        // Show toast
        const bsToast = new bootstrap.Toast(toast, { delay: 3000 });
        bsToast.show();
        
        // Remove from DOM after hiding
        toast.addEventListener('hidden.bs.toast', () => {
            toast.remove();
        });
    }
    
    /**
     * Get current result
     */
    getCurrentResult() {
        return this.currentResult;
    }
    
    /**
     * Get result history
     */
    getHistory() {
        return this.resultHistory;
    }
    
    /**
     * Clear history
     */
    clearHistory() {
        this.resultHistory = [];
        this.updateHistoryDisplay();
        this.showToast('Info', 'History cleared', 'info');
    }
    
    /**
     * Check if results section has content
     */
    hasResults() {
        return this.currentResult !== null;
    }
    
    /**
     * Destroy and cleanup
     */
    destroy() {
        if (this.container) {
            this.container.innerHTML = '';
        }
        
        // Remove global reference
        if (window.resultsSection === this) {
            delete window.resultsSection;
        }
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    // Node.js environment
    module.exports = { SystemDashboard, SmartFormControls, ToolsSection, ResultsSection };
} else {
    // Browser environment - attach to window
    window.SystemDashboard = SystemDashboard;
    window.SmartFormControls = SmartFormControls;
    window.ToolsSection = ToolsSection;
    window.ResultsSection = ResultsSection;
}